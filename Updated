importmportackage com.aadhaar.linkage.service;

import com.aadhaar.linkage.dto.LinkageRequest;
import com.aadhaar.linkage.dto.LinkageResponse;
import com.aadhaar.linkage.model.PersonIdentity;
import com.aadhaar.linkage.repository.LinkageRepository;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class LinkageService {

    private final LinkageRepository repo;

    public LinkageService(LinkageRepository repo) {
        this.repo = repo;
    }

    // ---------------- MAIN DISPATCHER ----------------
    public LinkageResponse processRequest(LinkageRequest req) {
        String action = req.getAction().trim().toUpperCase(Locale.ROOT);
        switch (action) {
            case "INSERT": return insertRecord(req);
            case "UPDATE": return updateRecord(req);
            case "DELETE": return deleteRecord(req);
            case "SEARCH": return searchRecord(req);
            default: return LinkageResponse.error("Invalid action: " + req.getAction());
        }
    }

    // ---------------- INSERT ----------------
    private LinkageResponse insertRecord(LinkageRequest req) {
        Map<String, String> data = req.getData();
        if (data == null || data.isEmpty())
            return LinkageResponse.error("Data is required for INSERT");

        String forename = normalize(data.get("forename"));
        String dob = normalize(data.get("dob"));
        if (forename == null || dob == null)
            return LinkageResponse.error("Forename and DOB required to identify person");

        String hForename = hash(forename);
        String hDob = hash(dob);

        // Check if person already exists
        Optional<PersonIdentity> existingOpt = repo.findByHashedForenameAndHashedDob(hForename, hDob);
        PersonIdentity person;
        boolean createdNew = false;

        if (existingOpt.isPresent()) {
            person = existingOpt.get();
        } else {
            person = new PersonIdentity();
            person.setAadhaarLinkageKey(UUID.randomUUID().toString());
            person.setHashedForename(hForename);
            person.setHashedDob(hDob);
            person.setHashedAddress(hash(data.get("address")));
            person.setGender(data.get("gender"));
            initCounters(person);
            createdNew = true;
        }

        // Based on source, set counter = 1 if inserting for first time
        String source = req.getSource().toUpperCase(Locale.ROOT);
        switch (source) {
            case "AADHAAR":
                if (createdNew || person.getAadhaarCounter() == 0)
                    person.setAadhaarCounter(1);
                break;
            case "PAN":
                if (createdNew || person.getPanCounter() == 0)
                    person.setPanCounter(1);
                break;
            case "VOTER":
                if (createdNew || person.getVoterIdCounter() == 0)
                    person.setVoterIdCounter(1);
                break;
            case "DRIVING":
                if (createdNew || person.getDlCounter() == 0)
                    person.setDlCounter(1);
                break;
            default:
                return LinkageResponse.error("Invalid source: " + source);
        }

        repo.save(person);
        return LinkageResponse.success(
                existingOpt.isPresent() ? "Record updated with new source" : "Record inserted successfully",
                summary(person)
        );
    }

    // ---------------- UPDATE ----------------
    private LinkageResponse updateRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for UPDATE");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        PersonIdentity p = opt.get();
        String source = req.getSource().toUpperCase(Locale.ROOT);

        switch (source) {
            case "AADHAAR": p.setAadhaarCounter(p.getAadhaarCounter() + 1); break;
            case "PAN": p.setPanCounter(p.getPanCounter() + 1); break;
            case "VOTER": p.setVoterIdCounter(p.getVoterIdCounter() + 1); break;
            case "DRIVING": p.setDlCounter(p.getDlCounter() + 1); break;
            default: return LinkageResponse.error("Invalid source for update: " + source);
        }

        repo.save(p);
        return LinkageResponse.success("Record updated successfully", summary(p));
    }

    // ---------------- DELETE ----------------
    private LinkageResponse deleteRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for DELETE");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        PersonIdentity p = opt.get();
        String source = req.getSource().toUpperCase(Locale.ROOT);

        switch (source) {
            case "AADHAAR":
                p.setAadhaarCounter(Math.max(0, p.getAadhaarCounter() - 1));
                break;
            case "PAN":
                p.setPanCounter(Math.max(0, p.getPanCounter() - 1));
                break;
            case "VOTER":
                p.setVoterIdCounter(Math.max(0, p.getVoterIdCounter() - 1));
                break;
            case "DRIVING":
                p.setDlCounter(Math.max(0, p.getDlCounter() - 1));
                break;
            default:
                return LinkageResponse.error("Invalid source for delete: " + source);
        }

        // If all counters = 0, delete the record
        if (p.getAadhaarCounter() == 0 && p.getPanCounter() == 0 &&
            p.getVoterIdCounter() == 0 && p.getDlCounter() == 0) {
            repo.delete(p);
            return LinkageResponse.success("All sources removed â€” record deleted completely");
        }

        repo.save(p);
        return LinkageResponse.success("Source deleted successfully", summary(p));
    }

    // ---------------- SEARCH ----------------
    private LinkageResponse searchRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for SEARCH");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        return LinkageResponse.success("Record found", summary(opt.get()));
    }

    // ---------------- HELPERS ----------------
    private void initCounters(PersonIdentity p) {
        p.setAadhaarCounter(0);
        p.setPanCounter(0);
        p.setVoterIdCounter(0);
        p.setDlCounter(0);
    }

    private Map<String, Object> summary(PersonIdentity p) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("aadhaarLinkageKey", p.getAadhaarLinkageKey());
        map.put("aadhaarCounter", counterLabel(p.getAadhaarCounter()));
        map.put("panCounter", counterLabel(p.getPanCounter()));
        map.put("voterIdCounter", counterLabel(p.getVoterIdCounter()));
        map.put("dlCounter", counterLabel(p.getDlCounter()));
        return map;
    }

    private String counterLabel(int count) {
        return (count <= 0) ? "Data source not available" : String.valueOf(count);
    }

    private String normalize(String s) {
        return s == null ? null : s.trim().toLowerCase();
    }

    private String hash(String value) {
        if (value == null) return null;
        return Integer.toHexString(value.hashCode());
    }
}







private LinkageResponse validateRequest(LinkageRequest req) {

    if (req == null) {
        return LinkageResponse.error("Request payload cannot be null");
    }

    if (req.getAction() == null || req.getAction().isBlank()) {
        return LinkageResponse.error("Action is required");
    }

    Set<String> validActions = Set.of("INSERT", "UPDATE", "DELETE", "SEARCH");
    String action = req.getAction().trim().toUpperCase();

    if (!validActions.contains(action)) {
        return LinkageResponse.error("Invalid action: " + req.getAction());
    }

    // --- Source validation ---
    if (!action.equals("SEARCH")) {
        if (req.getSource() == null || req.getSource().isBlank()) {
            return LinkageResponse.error("Source is required");
        }

        Set<String> validSources = Set.of("AADHAAR", "PAN", "VOTER", "DRIVING");

        if (!validSources.contains(req.getSource().trim().toUpperCase())) {
            return LinkageResponse.error("Invalid source: " + req.getSource());
        }
    }

    // --- Data validation for INSERT/UPDATE ---
    if (action.equals("INSERT") || action.equals("UPDATE")) {

        Map<String, String> data = req.getData();

        if (data == null || data.isEmpty()) {
            return LinkageResponse.error("Data cannot be empty for INSERT/UPDATE");
        }

        for (Object v : data.values()) {
            if (!(v instanceof String)) {
                return LinkageResponse.error("All data fields must be strings");
            }
        }

        List<String> required = List.of("forename", "dob");

        for (String key : required) {
            if (!data.containsKey(key) || data.get(key).isBlank()) {
                return LinkageResponse.error(key + " is required");
            }
        }

        // allowed keys
        Set<String> allowedKeys = Set.of(
            "forename","secondname","lastname","dob",
            "aadhaar_number","pan_number","dl_number",
            "voter_id","address","gender"
        );

        for (String key : data.keySet()) {
            if (!allowedKeys.contains(key)) {
                return LinkageResponse.error("Unknown field: " + key);
            }
        }

        // source-specific field
        switch (req.getSource().trim().toUpperCase()) {
            case "AADHAAR":
                if (!data.containsKey("aadhaar_number"))
                    return LinkageResponse.error("aadhaar_number required");
                break;
            case "PAN":
                if (!data.containsKey("pan_number"))
                    return LinkageResponse.error("pan_number required");
                break;
            case "VOTER":
                if (!data.containsKey("voter_id"))
                    return LinkageResponse.error("voter_id required");
                break;
            case "DRIVING":
                if (!data.containsKey("dl_number"))
                    return LinkageResponse.error("dl_number required");
                break;
        }
    }

    // --- old key validation ---
    if (action.equals("UPDATE") || action.equals("DELETE") || action.equals("SEARCH")) {
        if (req.getOldAadhaarLinkageKey() == null || req.getOldAadhaarLinkageKey().isBlank()) {
            return LinkageResponse.error("oldAadhaarLinkageKey is required");
        }
    }

    return LinkageResponse.success("VALID");
}


LinkageResponse vr = validateRequest(req);
if (!"SUCCESS".equals(vr.getStatus())) {
    return vr;
}













private LinkageResponse validateRequest(LinkageRequest req) {

    if (req == null) {
        return LinkageResponse.error("Request payload cannot be null");
    }

    if (req.getAction() == null || req.getAction().isBlank()) {
        return LinkageResponse.error("Action is required");
    }

    Set<String> validActions = Set.of("INSERT", "UPDATE", "DELETE", "SEARCH");
    String action = req.getAction().trim().toUpperCase();

    if (!validActions.contains(action)) {
        return LinkageResponse.error("Invalid action: " + req.getAction());
    }

    // --- Source validation ---
    if (!action.equals("SEARCH")) {
        if (req.getSource() == null || req.getSource().isBlank()) {
            return LinkageResponse.error("Source is required");
        }

        Set<String> validSources = Set.of("AADHAAR", "PAN", "VOTER", "DRIVING");

        if (!validSources.contains(req.getSource().trim().toUpperCase())) {
            return LinkageResponse.error("Invalid source: " + req.getSource());
        }
    }

    // --- Data validation for INSERT/UPDATE ---
    if (action.equals("INSERT") || action.equals("UPDATE")) {

        Map<String, String> data = req.getData();

        if (data == null || data.isEmpty()) {
            return LinkageResponse.error("Data cannot be empty for INSERT/UPDATE");
        }

        for (Object v : data.values()) {
            if (!(v instanceof String)) {
                return LinkageResponse.error("All data fields must be strings");
            }
        }

        // required fields
        List<String> required = List.of("forename", "dob");
        for (String key : required) {
            if (!data.containsKey(key) || data.get(key).isBlank()) {
                return LinkageResponse.error(key + " is required");
            }
        }

        // allowed keys
        Set<String> allowedKeys = Set.of(
            "forename","secondname","lastname","dob",
            "aadhaar_number","pan_number","dl_number",
            "voter_id","address","gender"
        );

        for (String key : data.keySet()) {
            if (!allowedKeys.contains(key)) {
                return LinkageResponse.error("Unknown field: " + key);
            }
        }

        // ----------------------------
        // FIELD-LEVEL STRICT VALIDATION
        // ----------------------------

        // Aadhaar validation
        if (data.containsKey("aadhaar_number")) {
            String aadhaar = data.get("aadhaar_number");
            if (!aadhaar.matches("\\d{12}")) {
                return LinkageResponse.error("Invalid aadhaar_number: must be 12 digits");
            }
        }

        // PAN validation
        if (data.containsKey("pan_number")) {
            String pan = data.get("pan_number").toUpperCase();
            if (!pan.matches("[A-Z]{5}[0-9]{4}[A-Z]")) {
                return LinkageResponse.error("Invalid pan_number format");
            }
        }

        // Voter ID validation
        if (data.containsKey("voter_id")) {
            String voter = data.get("voter_id").toUpperCase();
            if (!voter.matches("[A-Z]{3}[0-9]{7}")) {
                return LinkageResponse.error("Invalid voter_id format");
            }
        }

        // Driving license validation (generic)
        if (data.containsKey("dl_number")) {
            String dl = data.get("dl_number").toUpperCase();
            if (!dl.matches("[A-Z]{2}-[0-9]{2}-[0-9]{11}")) {
                return LinkageResponse.error("Invalid dl_number format (expected: XX-00-00000000000)");
            }
        }

        // DOB validation: yyyy-MM-dd
        String dob = data.get("dob");
        if (!dob.matches("\\d{4}-\\d{2}-\\d{2}")) {
            return LinkageResponse.error("Invalid dob format, expected yyyy-MM-dd");
        }
        try {
            LocalDate.parse(dob);
        } catch (Exception e) {
            return LinkageResponse.error("Invalid dob date value");
        }

        // Gender validation
        if (data.containsKey("gender")) {
            String g = data.get("gender").trim().toUpperCase();
            if (!Set.of("M","F","O").contains(g)) {
                return LinkageResponse.error("Invalid gender: allowed values are M, F, O");
            }
        }

        // source-specific required key
        switch (req.getSource().trim().toUpperCase()) {
            case "AADHAAR":
                if (!data.containsKey("aadhaar_number"))
                    return LinkageResponse.error("aadhaar_number required");
                break;
            case "PAN":
                if (!data.containsKey("pan_number"))
                    return LinkageResponse.error("pan_number required");
                break;
            case "VOTER":
                if (!data.containsKey("voter_id"))
                    return LinkageResponse.error("voter_id required");
                break;
            case "DRIVING":
                if (!data.containsKey("dl_number"))
                    return LinkageResponse.error("dl_number required");
                break;
        }
    }

    // --- old key validation ---
    if (action.equals("UPDATE") || action.equals("DELETE") || action.equals("SEARCH")) {
        if (req.getOldAadhaarLinkageKey() == null || req.getOldAadhaarLinkageKey().isBlank()) {
            return LinkageResponse.error("oldAadhaarLinkageKey is required");
        }
    }

    return LinkageResponse.success("VALID");
}
