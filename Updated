package com.aadhaar.linkage.service;

import com.aadhaar.linkage.dto.LinkageRequest;
import com.aadhaar.linkage.dto.LinkageResponse;
import com.aadhaar.linkage.model.PersonIdentity;
import com.aadhaar.linkage.repository.LinkageRepository;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class LinkageService {

    private final LinkageRepository repo;

    public LinkageService(LinkageRepository repo) {
        this.repo = repo;
    }

    // ---------------- MAIN DISPATCHER ----------------
    public LinkageResponse processRequest(LinkageRequest req) {
        String action = req.getAction().trim().toUpperCase(Locale.ROOT);
        switch (action) {
            case "INSERT": return insertRecord(req);
            case "UPDATE": return updateRecord(req);
            case "DELETE": return deleteRecord(req);
            case "SEARCH": return searchRecord(req);
            default: return LinkageResponse.error("Invalid action: " + req.getAction());
        }
    }

    // ---------------- INSERT ----------------
    private LinkageResponse insertRecord(LinkageRequest req) {
        Map<String, String> data = req.getData();
        if (data == null || data.isEmpty())
            return LinkageResponse.error("Data is required for INSERT");

        String forename = normalize(data.get("forename"));
        String dob = normalize(data.get("dob"));
        if (forename == null || dob == null)
            return LinkageResponse.error("Forename and DOB required to identify person");

        String hForename = hash(forename);
        String hDob = hash(dob);

        // Check if person already exists
        Optional<PersonIdentity> existingOpt = repo.findByHashedForenameAndHashedDob(hForename, hDob);
        PersonIdentity person;
        boolean createdNew = false;

        if (existingOpt.isPresent()) {
            person = existingOpt.get();
        } else {
            person = new PersonIdentity();
            person.setAadhaarLinkageKey(UUID.randomUUID().toString());
            person.setHashedForename(hForename);
            person.setHashedDob(hDob);
            person.setHashedAddress(hash(data.get("address")));
            person.setGender(data.get("gender"));
            initCounters(person);
            createdNew = true;
        }

        // Based on source, set counter = 1 if inserting for first time
        String source = req.getSource().toUpperCase(Locale.ROOT);
        switch (source) {
            case "AADHAAR":
                if (createdNew || person.getAadhaarCounter() == 0)
                    person.setAadhaarCounter(1);
                break;
            case "PAN":
                if (createdNew || person.getPanCounter() == 0)
                    person.setPanCounter(1);
                break;
            case "VOTER":
                if (createdNew || person.getVoterIdCounter() == 0)
                    person.setVoterIdCounter(1);
                break;
            case "DRIVING":
                if (createdNew || person.getDlCounter() == 0)
                    person.setDlCounter(1);
                break;
            default:
                return LinkageResponse.error("Invalid source: " + source);
        }

        repo.save(person);
        return LinkageResponse.success(
                existingOpt.isPresent() ? "Record updated with new source" : "Record inserted successfully",
                summary(person)
        );
    }

    // ---------------- UPDATE ----------------
    private LinkageResponse updateRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for UPDATE");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        PersonIdentity p = opt.get();
        String source = req.getSource().toUpperCase(Locale.ROOT);

        switch (source) {
            case "AADHAAR": p.setAadhaarCounter(p.getAadhaarCounter() + 1); break;
            case "PAN": p.setPanCounter(p.getPanCounter() + 1); break;
            case "VOTER": p.setVoterIdCounter(p.getVoterIdCounter() + 1); break;
            case "DRIVING": p.setDlCounter(p.getDlCounter() + 1); break;
            default: return LinkageResponse.error("Invalid source for update: " + source);
        }

        repo.save(p);
        return LinkageResponse.success("Record updated successfully", summary(p));
    }

    // ---------------- DELETE ----------------
    private LinkageResponse deleteRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for DELETE");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        PersonIdentity p = opt.get();
        String source = req.getSource().toUpperCase(Locale.ROOT);

        switch (source) {
            case "AADHAAR":
                p.setAadhaarCounter(Math.max(0, p.getAadhaarCounter() - 1));
                break;
            case "PAN":
                p.setPanCounter(Math.max(0, p.getPanCounter() - 1));
                break;
            case "VOTER":
                p.setVoterIdCounter(Math.max(0, p.getVoterIdCounter() - 1));
                break;
            case "DRIVING":
                p.setDlCounter(Math.max(0, p.getDlCounter() - 1));
                break;
            default:
                return LinkageResponse.error("Invalid source for delete: " + source);
        }

        // If all counters = 0, delete the record
        if (p.getAadhaarCounter() == 0 && p.getPanCounter() == 0 &&
            p.getVoterIdCounter() == 0 && p.getDlCounter() == 0) {
            repo.delete(p);
            return LinkageResponse.success("All sources removed â€” record deleted completely");
        }

        repo.save(p);
        return LinkageResponse.success("Source deleted successfully", summary(p));
    }

    // ---------------- SEARCH ----------------
    private LinkageResponse searchRecord(LinkageRequest req) {
        String key = req.getOldAadhaarLinkageKey();
        if (key == null || key.isBlank())
            return LinkageResponse.error("AadhaarLinkageKey required for SEARCH");

        Optional<PersonIdentity> opt = repo.findById(key);
        if (opt.isEmpty())
            return LinkageResponse.error("Record not found for key: " + key);

        return LinkageResponse.success("Record found", summary(opt.get()));
    }

    // ---------------- HELPERS ----------------
    private void initCounters(PersonIdentity p) {
        p.setAadhaarCounter(0);
        p.setPanCounter(0);
        p.setVoterIdCounter(0);
        p.setDlCounter(0);
    }

    private Map<String, Object> summary(PersonIdentity p) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("aadhaarLinkageKey", p.getAadhaarLinkageKey());
        map.put("aadhaarCounter", counterLabel(p.getAadhaarCounter()));
        map.put("panCounter", counterLabel(p.getPanCounter()));
        map.put("voterIdCounter", counterLabel(p.getVoterIdCounter()));
        map.put("dlCounter", counterLabel(p.getDlCounter()));
        return map;
    }

    private String counterLabel(int count) {
        return (count <= 0) ? "Data source not available" : String.valueOf(count);
    }

    private String normalize(String s) {
        return s == null ? null : s.trim().toLowerCase();
    }

    private String hash(String value) {
        if (value == null) return null;
        return Integer.toHexString(value.hashCode());
    }
}
